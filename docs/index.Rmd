---
title: "Project Euler Miscellaneous"
author: "Richard Ryan"
date: '6 April 2022'
output: 
   html_document:
      css: style.css
      theme: flatly
      highlight: pygments
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
   echo = TRUE, 
   message = FALSE, 
   warning = FALSE, 
   paged.print = FALSE
)
```

<body style="background-color:#F3F4F2;">

We have completed the first ten problem from Project Euler [here](https://rich1707.github.io/Project-Euler-1/). We now take a look at some additional problems. None of these problems involve any advanced mathematics but they do provide invaluable experience in using `R` to solve problems outside the field of data science. 

```{r}

library(numbers)
library(gmp)
library(Zseq)
library(gtools)
library(lubridate)

```

## Problem 12: Highly divisible triangular number

**The Problem:**

*The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be* $1 + 2 + 3 + 4 + 5 + 6 + 7 = 28$. *The first ten terms would be:* $$1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...$$

*We can see that 28 is the first triangle number to have over five divisors:*

*What is the value of the first triangle number to have over five hundred divisors?*

**The solution:**

We can easily generate the triangle numbers using a `while()` loop and the conveniently vectorised `sum()` function. We use the `length()` function from base `R` and the `divisors()` function from the `numbers` package to keep track of the number of divisors. We loop until the number of divisors exceeds 500, at which point we have our solution.

```{r}

triangle_number <- NA_integer_
number_of_divisors <- 1
index_number <- 1
while(number_of_divisors <= 500){
   triangle_number <- sum(1: index_number)
   number_of_divisors <- length(divisors(triangle_number))
   index_number <- index_number + 1
}
triangle_number

```

## Problem 14: Longest Collatz sequence

**The problem:**

*The following iterative sequence is defined for the set of positive integers:* 
$$n → n/2 (\textrm{n is even})$$ 


$$n → 3n + 1 (\textrm{n is odd})$$
*Using the rule above and starting with 13, we generate the following sequence:* $$13 → 40 → 20 → 10 → 5 → 16 → 8 → 4 → 2 → 1$$

*It can be seen that this sequence (starting at 13 and finishing at 1) contains 10 terms. Although it has not been proved yet (Collatz Problem), it is thought that all starting numbers finish at 1.*

*Which starting number, under one million, produces the longest chain?*

**The solution**

Once again, the `numbers` package has the function we need. We loop over all numbers less than or equal to 1 million, using the `length()` and the `collatz()` functions to keep track of the length of the collatz chain each number generates. 

We could use a `for()` loop for this purpose, but in this case it is easier to use `lapply()`. As `lapply()` returns a list we must remember to `unlist()` and select the longest sequence using the `which.max()` function. This function returns the index position of the term with the longest sequence, which in this case, as we iterated over all numbers from 1 to 1000000, is the same thing as the number itself.  

```{r}

lapply(1:1e6, function(.x) length(collatz(.x))) |>
   unlist() |>
   which.max()

```

## Problem 16

**The problem:**

$2^{15} = 32768$ and the sum of its digits is $3 + 2 + 7 + 6 + 8 = 26$.

*What is the sum of the digits of the number* $2^{1000}$?

**The solution:**

It is worth including this problem just to introduce the `gmp` package, which allows us to bypass `R`'s defaults on representing large numbers. When we use the `as.bigz()` function, the problem becomes trivial: we convert the number to a string, split the string, convert it to a vector and pass it to the `sum()` function.

```{r}

as.bigz(2**1000) |>
   as.character() |>
   strsplit(split = "") |>
   unlist() |>
   as.numeric() |>
   sum()

```

## Problem 17: Number letter counts

**The problem:**

*If the numbers 1 to 5 are written out in words: one, two, three, four, five, then there are 3 + 3 + 5 + 4 + 4 = 19 letters used in total.*

*If all the numbers from 1 to 1000 (one thousand) inclusive were written out in words, how many letters would be used?*

**NOTE**: *Do not count spaces or hyphens. For example, 342 (three hundred and forty-two) contains 23 letters and 115 (one hundred and fifteen) contains 20 letters. The use of "and" when writing out numbers is in compliance with British usage.*

**The solution:**

Start by creating two vectors of number words as follows:

```{r}

twenty_or_less <- c("one", "two", "three", "four", "five", "six", "seven", "eight", "nine", 
                    "ten", "eleven", "twelve", "thirteen", "fourteen", "fifteen", "sixteen", 
                    "seventeen", "eighteen", "nineteen", "twenty")

ten_and_multiples <- c("ten", "twenty", "thirty", "forty", "fifty", "sixty", 
                       "seventy", "eighty", "ninety")

```

We use the `paste0()` function to collapse `twenty_or_less` into a single string and we use `nchar()` to count the number of characters it contains. We store this in a variable called `number_words_20`.

We then move on to all numbers between 20 and 100. Here we use a `for()` loop to iterate over numbers from 21 to 99. On each iteration of the loop, we pass the index *i* to the function `floor(i / 10)`. The resulting number is used to filter the `ten_and_multiples` vector above. We then use the function `i - (10 * floor(i / 10))` to find the remainder (if any), with which we filter the `twenty_or_less` vector. All we then have to do, is `paste0()` these values together and assign it to the correct position in our `number_words_99` vector. 

When the loop has concluded, we use `paste0()` and `nchar()` on the `number_words_99` vector to arrive at the number of characters.

We repeat this process for numbers between 100 and 999 with obvious modifications, such as using `paste0()` to add the terms "hundred" and "and" when appropriate. 

Finally we calculate the number of characters in the string "one thousand". All that reamins to obtain  the answer is to pass all of the values we have calculated to the `sum()` function. 

```{r}

number_words_20 <- 
   paste0(twenty_or_less, collapse = "") |>
   nchar()

number_words_99 <- character()

for(i in 21:99) {
   number_word <- ten_and_multiples[floor(i / 10)]
   number_word <- paste0(number_word, twenty_or_less[i - (10 * floor(i / 10))])
   number_words_99[i - 20] <- number_word
}

number_words_99 <- 
   paste0(number_words_99, collapse = "") |>
   nchar()

number_words_999 <- character()

for(i in 100:999) {
   number_word <- paste0(twenty_or_less[floor((i / 100))], "hundred")
   remainder <- i - (100 * floor(i / 100))
   if(remainder > 0) {
      number_word <- paste0(number_word, "and")
      if(remainder < 21) {
         number_word <- paste0(number_word, twenty_or_less[remainder])
      } else {
         number_word <- paste0(number_word, ten_and_multiples[floor(remainder / 10)])
         number_word <- paste0(number_word, twenty_or_less[remainder - (10 * floor(remainder / 10))])
      }
   }
   number_words_999[i - 99] <- number_word 
}

number_words_999 <- 
   paste0(number_words_999, collapse = "") |>
   nchar()

number_words_1000 <- 
   paste0("one", "thousand", collapse = "") |>
   nchar()

sum(number_words_20, number_words_99, number_words_999, number_words_1000)

```

## Problem 19: Counting Sundays

**The problem:**

*How many Sundays fell on the first of the month during the twentieth century (1 Jan 1901 to 31 Dec 2000)?*

**The solution**

We start with a vector of all dates from the first date above to the second. Next we use `floor_date()` and `unique()` to return the first day of every month. The `wday()` function tells us what weekday each date fell on. All that remains is to count the Sundays. 

```{r}

all_dates <- seq(as_date("1901-01-01"), as_date("2000-12-31"), by = 1)

first_of_month <- 
   floor_date(all_dates, "month") |>
   unique()

first_weekday <- wday(first_of_month, label = TRUE)

first_weekday[first_weekday == "Sun"] |>
   length()

```

## Problem 20: Factorial digit sum

**The Problem:**

$n!$ *means* $n × (n − 1) × ... × 3 × 2 × 1$

*For example,* $10! = 10 × 9 × ... × 3 × 2 × 1 = 3628800$,
*and the sum of the digits in the number* $10!$ *is* $3 + 6 + 2 + 8 + 8 + 0 + 0 = 27$.

*Find the sum of the digits in the number* $100!$

**The solution:**

This is one of the easier problems. We use the `factorialZ()` function from the `gmp` package to represent $100!$. We then covert it to a string using `as.character()`, split it into its components using `strsplit()`, convert it into a numeric vector using `as.numeric()` and pass it to the `sum()` function. 


```{r}

factorialZ(100) |>
   as.character() |>
   strsplit(split = "") |>
   unlist() |>
   as.numeric() |>
   sum() 

```

## Problem 21: Amicable numbers

**The problem:**

*Let d(n) be defined as the sum of proper divisors of n (numbers less than n which divide evenly into n).*
*If d(a) = b and d(b) = a, where a ≠ b, then a and b are an amicable pair and each of a and b are called amicable numbers.*

*For example, the proper divisors of 220 are 1, 2, 4, 5, 10, 11, 20, 22, 44, 55 and 110; therefore d(220) = 284. The proper divisors of 284 are 1, 2, 4, 71 and 142; so d(284) = 220.*

*Evaluate the sum of all the amicable numbers under 10000.*

**The solution:**

A simple enough problem. As we are only interested in numbers less than 10,000, we use a `for()` loop to iterate over all numbers from 2 to 9,999. We use the `divisors()` function to find the divisors of the value of *i* before summing them and deducting *i*. This gives us the `sum()` of the proper divisors, which we store as `first_number`. We then sum `sum()` the proper divisors of `first_number` storing it as `second_number`.

We now need to test whether `first_number` and `second_number` are amicable. There are two conditions to satisfy here: 

* the `second_number` must be equal to *i* 
* the `first_number` must not be perfect, *i.e.* must be different from the sum of its proper divisors.

All that then remains is to `sum()` up the `amicable_numbers` vector to obtain our solution.


```{r}

amicable_numbers <- numeric()
for(i in 2: 9999) {
   first_number <- divisors(i) |> 
      sum() - i
   second_number <- divisors(first_number) |> 
      sum() - first_number
   if(first_number != i & second_number == i) {
      amicable_numbers <- c(amicable_numbers, i)
   }
}

amicable_numbers |>
   sum()

```

## Problem 22: Names scores

**The problem:**

*Using names.txt (right click and 'Save Link/Target As...'), a 46K text file containing over five-thousand first names, begin by sorting it into alphabetical order. Then working out the alphabetical value for each name, multiply this value by its alphabetical position in the list to obtain a name score.*

*For example, when the list is sorted into alphabetical order, COLIN, which is worth 3 + 15 + 12 + 9 + 14 = 53, is the 938th name in the list. So, COLIN would obtain a score of 938 × 53 = 49714.*

*What is the total of all the name scores in the file?*

**The solution:**

We first need to read in the text file, strip away the punctuation and sort into alphabetical order. Using a `for()` loop over the `all_names` vector, we split each name into its component characters and match each of these characters in the inbuilt `letters` vector. This gives us a vector of the index position in the alphabet of each of the letters in the name, which we `sum()` and then multiply by the index position in the `all_names` vector. We then have our score for the name in question, which we store in the `split_name_value` vector. Once the `for()` loop has completed, we simply `sum()` up hte values to find our answer.

```{r}

all_names <- readLines("p022_names.txt") |>
   strsplit(",") |>
   unlist()

all_names <- gsub("[[:punct:]]", "", all_names) |>
   tolower() |>
   sort()

name_scores <- rep(0, length(all_names))

for(i in seq_along(all_names)) {
   split_name_value <- strsplit(all_names[i], "") |>
      unlist() |>
      match(letters) |>
      sum()
   name_scores[i] <- split_name_value * i
}

sum(name_scores)

```


## Problem 24: Lexicographic permutations

**The problem:**

*A permutation is an ordered arrangement of objects. For example, 3124 is one possible permutation of the digits 1, 2, 3 and 4. If all of the permutations are listed numerically or alphabetically, we call it lexicographic order. The lexicographic permutations of 0, 1 and 2 are:* $$\textrm{012 021 102 120 201 210.}$$ 

*What is the millionth lexicographic permutation of the digits 0, 1, 2, 3, 4, 5, 6, 7, 8 and 9?*

**The solution:**

This is a tricky problem, but fortunately we have the `permutations()` function from the `gtools` package to do the heavy lifting for us. Start by creating a character vector of the numerals from 0 to 9. Then create all possible ten digit permutations from the `numerals` vector. We then select the one millionth item, collapse it into a single term using `paste0()` and convert it to a number. 

```{r}

numerals <- as.character(0:9) 

perms <- permutations(n = 10, r = 10, v = numerals)

perms[1e6, ] |>
   paste0(collapse = "") |>
   as.numeric()

```

## Problem 25: 1000-digit Fibonacci number

**The problem:**

*The Fibonacci sequence is defined by the recurrence relation:*
$$F_n = F_{n−1} + F_{n−2}, \textrm{ where } F_1 = 1 \textrm{ and } F_2 = 1.$$
*The 12th term,* 
$$F_{12} = 144$$ 
*is the first term to contain three digits.*

*What is the index of the first term in the Fibonacci sequence to contain 1000 digits?*

**The solution:**

Here we need a `while()` loop. 

We initialise two variables, `first_number` and `second_number`, at 0 and 1 respectively. We then use these variables to build the Fibonacci sequence, with the `as.bigz()` function ensuring that the numbers in the sequence are returned in the correct format. 

For each number, we convert to a string and count the number of characters. When the number of characters reaches 1000 or more, we break out of the loop. 

```{r}

first_number <- 0
second_number <- 1
index <- 1
num_char <- 0

while(num_char < 1000) {
   fib_number <- as.bigz(first_number + second_number)
   num_char <- fib_number |>
      as.character() |>
      nchar()
   first_number <- second_number
   second_number <- fib_number
   
   index <- index + 1
}

index

```

## Problem 26: Reciprocal cycles

**The problem:**

*A unit fraction contains 1 in the numerator.* 

*For example, if we divide 1 by six we get*
$$0.16666...$$
*We call this a 1-digit recurring cycle, as a single digit, in this case 6, repeats forever. However, in the case of dividing 1 into 7, we have instead:*
$$0.1428571$$
*where the recurring cycle is six digits long - namely, *142857. 

*Find the value of d < 1000 for which 1/d contains the longest recurring cycle in its decimal fraction part.*

**The solution:**

We write a `calc_decimals()` function that performs long division. An interesting feature of this function is the `repeat()` loop which runs until either the sequence terminates or starts to recur.

Once we have written our function, we then use `lapply()` to iterate over all numbers less than 1000. We `unlist()` and use `which.max()` to select the number with the longest recurring decimal part. 

```{r}

calc_decimals <- function(x) {
   div_vec <- numeric()
   rem_vec <- numeric()
   base_num <- 10
   index <- 1
   if(x == 1) return(0)
   repeat {
      div_vec[index] <- floor(base_num / x)
      base_num <- 10 * (base_num %% x)
      if(base_num == 0 | base_num %in% rem_vec) 
         break
      rem_vec[index] <- base_num
      index <- index + 1
   }
   return(div_vec)
}

lapply(1:999, function(.x) length(calc_decimals(.x))) |>
   unlist() |>
   which.max()

```

Once again, none of the above problems venture beyond fairly basic mathematics. Nevertheless, problems like these do complement the sort of thinking required in data science projects, and are therefore well worth attempting.










































